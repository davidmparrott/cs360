/*
David Parrott
11239947
CS 360 assignment 8
Day/Time server

daytime.c connects to a remote host specified in argv[1] then
saves whatever is sent in a character buffer that is sent 
to STDOUT
*/
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <fcntl.h>

/*
port that daytime will listen for a connection on
*/
#define MY_PORT_NUMBER		49999
#define	COMMAND_SIZE		1024
/*
takes a char* that is assumed to be the adderss of a remote
machine listening for connections. Sets up the connection
and assigns it to socketfd which is returned for use by main
*/
int makeCon(char* arg, int port){
/*
variable declarations
socketfd gets bound to the socket
*/
	int socketfd;
	struct sockaddr_in servAddr;
	struct hostent* hostEntry;
	struct in_addr **pptr;
/*
initialize structs
*/
	memset(&servAddr, 0, sizeof(servAddr));
	servAddr.sin_family = AF_INET;
	servAddr.sin_port = htons(port);
/*
bind socketfd and get host name (with error checking)
*/
	if( (socketfd = socket(AF_INET, SOCK_STREAM, 0)) < 0){
		perror("socket");
		exit(1);
	}
	if((hostEntry = gethostbyname(arg)) < 0){
		herror("host name");
		exit(1);
	}
	pptr = (struct in_addr **) hostEntry->h_addr_list;
	memcpy(&servAddr.sin_addr, *pptr, sizeof(struct in_addr));
/*
open connection to remote machine
*/
	if((connect(socketfd, (struct sockaddr *) &servAddr, sizeof(servAddr))) < 0){
		perror("connect");
		exit(1);
	}
/*
return the now initialized socketfd
*/
	return(socketfd);
}

void cd(char* path){
	if(chdir(path) < 0){
		perror("cd error");
	}
	return;
}

void rcd(char* path, int fd){
	char* commandBuff = (char*)calloc(COMMAND_SIZE, sizeof(char));
	char reply[256];
	strcpy(commandBuff, "C");
	strcat(commandBuff, path);
	strcat(commandBuff, "\n");
	write(fd, commandBuff, strlen(commandBuff));
	read(fd, reply, 256);
	if(reply[0] == 'E'){
		printf("%s\n", reply+1);
	}
	free(commandBuff);
}

void ls(){
	system("ls -l | more -20");
	return;
}

int newPort(int fd){
	int port;
	char* sendTheD = "D\n";
	char reply[256];
	write(fd, sendTheD, 2);
	read(fd, reply, 256);
	if(reply[0] == 'E'){
		printf("%s\n", reply+1);
		return(-1);
	}else{
		sscanf(reply, "A%d\n", &port);
	}
	return port;
}

void rls(int datafd, int socketfd){
	char reply[256];
	int ecode;
	write(socketfd, "L\n", 2);
	read(socketfd, reply, 256);
	if(reply[0] == 'E'){
		printf("%s\n", reply+1);
	}else{
		char rlsBuff;
		while(read(datafd, &rlsBuff, 1)){
			if(rlsBuff == EOF){
				break;
			}else{
				printf("%c", rlsBuff);
			}
		}
	}
}

void get(char* path, int datafd, int socketfd, int filefd){
	char* fileBuff[512];
	char* reply[256];	
	char* gpath[strlen(path)+2];	
	int bytes;	
	strcpy(gpath, "G");
	strcat(gpath, path);
	strcat(gpath, "\n");
	write(socketfd, gpath, strlen(gpath));
	read(socketfd, reply, 256);
	if(reply[0] == "E"){
		printf("%s\n", reply+1);
	}else{
		while((bytes = read(datafd, fileBuff, 512) > 0){
			write(filefd, fileBuff, bytes);
		}
}

int main(int argc, char* argv[]){
/*
variable declarations
socketfd will get an initialized connection from makeCon
daytime is a character buffer to store information from 
the remote machine
*/
	int socketfd, PID;
	char* inputBuffer = (char*)calloc(COMMAND_SIZE, sizeof(char));
	char* instructionToken = (char*)calloc(COMMAND_SIZE, sizeof(char));
	char* commandToken = (char*)calloc(COMMAND_SIZE, sizeof(char));
	socketfd = makeCon(argv[1], MY_PORT_NUMBER);						//initialize socketfd

	while(1){
		printf("/:> ");
		fgets(inputBuffer, COMMAND_SIZE, stdin);
		instructionToken = strtok(inputBuffer, " \n\t\v\f\r");

		if(!strcmp(instructionToken, "exit")){
			write(socketfd, "Q\n", 2);
			printf("process terminated\n");
			close(socketfd);
			exit(0);
		}else if(!strcmp(instructionToken, "cd")){
			commandToken = strtok(NULL, "\n");
			cd(commandToken);
		}else if(!strcmp(instructionToken, "rcd")){
			commandToken = strtok(NULL, "\n");
			rcd(commandToken, socketfd);
		}else if(!strcmp(instructionToken, "ls")){
			commandToken = strtok(NULL, "\n");
			ls();
		}else if(!strcmp(instructionToken, "rls")){
			int port;
			int datafd;
			if((port = newPort(socketfd)) < 0){
				perror("rls data port error");
				continue;	
			}
			if((datafd = makeCon(argv[1], port)) < 0){
				perror("rls socket error");
				continue;
			}
			rls(datafd, socketfd);
			close(datafd);
		}else if(!strcmp(instructionToken, "get")){
			int port, datafd, filefd;
			char getBuff[256];

			commandToken = strtok(NULL, "\n\t\v\f\r");
			char* tempFileName = strtok(commandToken, "/");
			char* fileName = tempFileName;

			while((tempFileName = strtok(NULL, "/")) != NULL){
				fileName = tempFileName;
			}
			if((port = newPort(socketfd)) < 0){
				perror("get data port error");
				continue;	
			}
			if((datafd = makeCon(argv[1], port)) < 0){
				perror("get socket error");
				continue;
			}
			if((filefd = open(fileName, O_CREAT | O_EXCL | O_WRONLY | O_APPEND, 
										S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) < 0){
	  			perror("get file open error");
	  			continue;
			}
			get(commandToken, datafd, socketfd, filefd);


			strcpy(getBuff, "G");
			strcat(getBuff, commandToken);
			strcat(getBuff, "\n");
			write(socketfd, getBuff, strlen(getBuff));

		}

	}
	close(socketfd);									//close socketfd
	return 0;
}
